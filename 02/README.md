# パターンマッチ
* Elixir では `=` はマッチ演算子
* 左辺と右辺を等しくなると成功(≒代入)になる
```ex
a = 1  # 1
1 = a  # 1
2 = a  # 2 = 1と同じのため　** (MatchError) no match of right hand side value: 1

list = [1,2,3]
[a.b.c] = list  # [1,2,3] (a=1, b=2, c=3)
```
```ex
[1,_,_] = [1,2,3]  # [1,2,3] アンダースコアで無視も可能
```

## キャレット
* 変数の現在の値をパターンマッチで扱う
```ex
a = 1
a = 2  # これはokだが

a = 1
^a = 2 # これは現在のaの値(1)を使うためMatchError
```

## 知見
* 今まで「=」は代入の言語しかやってこなかったので、代入でないという考え方を理解するのに時間がかかった。。。
* ただ等式であると考えたら数学的な捉え方なので、そこまで違和感がなくなった

## 練習問題
練習問題1 どれがマッチするか
```ex
a = [1,2,3]         # ok
a = 4               # ok
4 = a               # ok
[a,b] = [1,2,3]     # MatchError
a = [[1,2,3]]       # ok
[a] = [[1,2,3]]     # ok
[[a]] = [[1,2,3]]   # MatchError
```

練習問題2 どれがマッチするか
```ex
[a,b,a] = [1,2,3]   # MatchError マッチ中は一度しか束縛できないため
[a,b,a] = [1,1,2]   # MatchError マッチ中は一度しか束縛できないため
[a,b,a] = [1,2,1]   # ok
```
練習問題3 どれがマッチするか(変数aが元々2であるとき)
```ex
[a,b,a] = [1,2,3]   # MatchError マッチ中は一度しか束縛できないため
[a,b,a] = [1,1,2]   # MatchError マッチ中は一度しか束縛できないため
a = 1               # ok
^a = 2              # MatchError aの中身は1のため
^a = 1              # ok
^a = 2 - a          # ok 1=2-1(=1)と同義なので
```
