# 複数のプロセスを使う
* Elxir の特徴の一つ「独立して並列に実行できる、小さな固まりにコードをまとめる」
* これはElang VMのおかげ（へー）
* Elixirでは平行性のためにアクター(_actor_)モデルを採用している
    * 独立したプロセスで他のプロセスと何も共有しない
    新しいプロセスを監視し、メッセージを送り、送り返す
* ElixirのプロセスはCPU上で動き、オーバーヘッドがとても小さい。そのため大量に作成することができる。

## シンプルなプロセス
* 関数を別プロセスで実行
* `spawn`はプロセスを一意に識別するプロセス識別子`PID`を返す。
```ex
spawn(SpaneBasic, :greet, [])   # PID<000>
```

* `send`関数でメッセージを送信。引数にPID、送信メッセージをとる
* アトムとタプルを送るのに使うことが多い
* `receive`を使ってメッセージを待ち受ける
    * メッセージをボディとしたcase文のように振る舞う。
```spawn1.ex
defmodule Spawn1 do 
  def greet do
    receive do  # メッセージを受け取り待ち
      {sender, msg} ->  # PIDとメッセージのタプルにマッチしたら受取
        send sender, {:ok, "Hello, #{msg}"} # sender(自分自身)へ送り返す
    end
  end
end

# モジュールの外側
pid = spawn(Spawn1, :greet, [])
send pid, {self, "World"}　# self(呼び出したプロセスのPID)をgreet関数に渡す（greet関数はどこに返事すればよいか分かる）

receive do                           # メッセージを受け取り待ち
  {:ok, message} -> IO.puts message  # タプルにマッチしたら受取メッセージ出力
end
```
* `spawn1.ex`を実行すると、、
    1. `pid = spawn(Spawn1, :greet, [])` でgreet関数実行。メッセージ受取待ち
    1. `send pid, {self, "World"}`でgreet関数の実行プロセスにメッセージ送信
    1. greet関数内の`send sender, {:ok, "Hello, #{msg}"}`が実行。自分自身のプロセスにタプルを送信。
    1. `{:ok, message} -> IO.puts message`が実行。出力。

* 関数のプロセスは関数を実行すると終了する。
* タイムアウト
```ex
receive do
  {:ok, message} -> IO.puts message
  after 500 -> # 処理   500ミリ秒でタイムアウト
end
```

## 複数プロセス
* 再帰を用いて実装
```ex
  def greet do
    receive do
      {sender, msg} -> send sender, {:ok, "Hello, #{msg}"}
      greet  # 再度呼び出し。
    end
  end
```

* Elixirには**末尾呼び出しの最適化**があるため、再帰により沢山のメッセージを呼び出しても危険ではない。
    * 関数が最後に自分自身を呼び出しているなら関数呼び出しの処理をする必要はない。
    * 最後に**関数**が実行されないと末尾回帰ではない
    * `def factorial(n), do: n*factorial(n-1)`はアウト
    * `def fact(n,acc), do: fact(n-1, acc*n)`はおｋ（アキュムレータを追加する）

## プロセスのリンク
* リンク : 片方についての通知をもう片方が受信する
* `spawn_link`を使う
    * プロセスの生成と呼び出し側のプロセスをリンクすることが出来る
    * 片方のプロセスが死ぬことでもう片方も終了するようになる
* OTPフレームワークでもプロセス監視してる

## プロセスのモニタ（監視）
* モニタ : 生成したプロセスの終了通知を受けるが、逆の通知がない。
* `spawn_monitor`を使う

## フィボナッチサーバー
* フィボナッチ数列を並行処理で解いていくもの
* Agentsでの効率化も行っている


## 練習問題
* 練習問題1 省略
* 練習問題2 # 空き時間に
* 練習問題3,4,5 # 空き時間に
* 練習問題6,7 # 空き時間に


## 知見
* プロセスのオーバーヘッドが小さいこと
* オブジェクト作る感覚でプロセスを作って良いこと
* 複数プロセスでの再帰の呼び出しは最適化されているが、注意も必要
* 章の最後にもあったが、プロセスを使ってプログラムを考えることに混乱している。。。（オブジェクト指向から来た民なので）
* 慣れていきたい。