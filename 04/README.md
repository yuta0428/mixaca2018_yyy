# Elixirの基礎

## 値型
* 数値、名前、範囲、正規表現がある
* 整数
```ex
1234    # 10進法
0xcafe  # 16進法
0o765   # 8進法
0b1010  # 2進法
```

```ex
1_000_000  # アンダースコアでの桁区切りもできる
```

* 浮動小数点数
    * 倍精度

* アトム
    * 何かの名前を表現する変数
    * `:fred`, `is_binary?`など(:)から始まる単一の語
    * 名前がそのまま自身の値になるため、同じアトム同士は同じになる。タグ値によく使われる。
```ex
a = :fred
a == :fred  # true
```

* 範囲
    * `start..end`と書く

* 正規表現
    * `~r{regexp}`, `~r{regexp}ops`]
    * 色々オプションある
```ex
Regex.run ~r{[aeiou]}, "caterpllar"  # ["a"]
```
## システム型
* PID
    * リモート、ローカルプロセスへの参照
* ポート
    * 書き込みリソースへの参照
* リファレンス
    * `make_ref`で一意なリファレンスが作成できる

## コレクション型
* タプル
    * `{}`で囲む
    * パターンマッチで利用されることがある
```ex
{status, file} = File.open("Hogefile")  # 成功: {:ok, #PID<0000>}  失敗: {:error, :enoent}
```

* リスト
    * `[]`で囲む
    * `[head(先頭要素) | tail(それ以降の要素)]` からなる
    * ヘッドの取得、テイルの取り出し、ヘッドへの追加は高速
    * ランダムな順番へのアクセスはコストが高い
```ex
[1,2,3] ++ [4,5,6]  # 連結 [1,2,3,4,5,6]
[1,2,3,4] -- [2,4]  # 差分 [1,3]
1 in [1,2,3,4]      # 含まれているか true
```

* キーワードリスト
    * `[]`で囲み、キーがatomで値のペアのリスト
    * 内部的にタプルのリストに変換される
    * キーが同じものを複数持つことが出来る。コマンドパラメータやオプションの受け渡しに有効。
```ex
[name: "Dave", city: "Dallas"]      # 内部的には [{name: "Dave"}, {city: "Dallas"}]
[1, name: "Dave", city: "Dallas"]   # わかり易い例 [1, {:name, "Dave"}, {:city, "Dallas"}]
```

* マップ
    * キーと値のペアのコレクション
    * `%{}`で囲み、キーと値を`=>`でつなぐ
    * キーの型は同じでなくても良い
    * 同じキーは上書きされる
```ex
map =  %{"one" => 1, :two => 2, {1,1,1} => 3}
map["one"]  # 1 角括弧で値取り出し
map.two     # 2 アトムの場合ドット記法でアクセス可能
```

## バイナリ
*   `<<>>`で囲む
* 修飾子を加えることでフィールド1個ずつの大きさを制御可能

    
```ex
bin = <<1, 2>>
byte_size bin  # 2
```
```ex
bin = <<3 :: size(2), 5 :: size(4)>>  # <<53::size(6)>>
```


## 演算子
* 基本演算子は一緒
```ex
div     # 除算
rem     # 余剰
a === b # 厳格な同値性（1 === 1.0 は false）
a == b  # 同値性（1 == 1.0 は true
```
```ex
binary1 <> binary2  # バイナリ（文字列）連結
list1 ++ list2      # リスト連結
```

* 比較の順序
    * 数値 < アトム < リファレンス < 関数 < ポート < pid < タプル < マップ < リスト < バイナリ


## with式
* 
* 計算中に一時的な変数を定義したく、その変数が外に漏れてほしくない時
```ex
content = "Now is the time"
lp = with {:ok, file} = File.open("Hogefile"),
          content     = IO.read(file, :all),
          :ok         = File.close(file),
          [_, uid, gid] = Regex.run(~r/_lp:(\d+):(\d+)/, content)
     do
          "gid: #{gid}, uid: #{uid}" 
     end
lp      # gid: 26, uid: 26 (Hogefileで読み込んだのが26という数字の場合)
content # Now is the time
```
* `<-`でMatchError時の値を指定できる。
```ex
with [a|_] <- [1,2,3], do: a    # 1
with [a|_] <- nil, do: a        # nil  
```

## 知見
* 今まで触れてきた言語に当てはめることで難なく理解はできた
* ただwith式が読んだときにすぐに頭に入るようになるにはもう少し慣れが必要。。。
* リスト、タプルの特性を把握し、実行効率のよいコードを意識する必要がある。
* キーワードリストとマップも特性を把握することで上手く使い分けていきたい。