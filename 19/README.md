# タスクとエージェント
* バックグラウンドで走る関数
* 機能的にはspawnとOTPの中間に位置する
  * spwan:  `send`, `receive`などの低レベルAPIで操作
  * OTP:  `GenServer`などの高機能プロセスアーキテクチャで操作
* OTPサーバーとして実装されている
  * アプリケーションの監視ツリーに追加できる

## タスク
* `Task.async/1`
  * 第1引数: 走らせる関数
  * 返り値: PIDと参照（タスクディスクリプタ）
  * 与えられた関数を走らせる独立したプロセスを生成する。
* `Task.await/1`
  * 第1引数: タスクディスクリプタ
  * 返り値: 実行した関数の返り値
  * バックグラウンドの関数が終了するまで待ち、関数の返り値を返す。

```ex
# 引数に与えた関数をバックグラウンドに待機
worker = Task.async(fn -> Fib.of(20) end)

# Task.awaitが呼び出されたタイミングで、関数を実行。実行が終了するまで待機
result = Task.await(worker)
```

下記のように、モジュール、関数名、引数を一緒に渡すことも可
```ex
worker = Task.async(Fib, :of, [20])
result = Task.await(worker)
```

### タスクと監視
* タスクをアプリケーションの監視ツリーに追加するには2つの方法がある。

1. `Task.async`の代わりに`start_link`を呼び、タスクをスーパーバイザに監視されているプロセスにリンクする。
    * タスク内の関数がクラッシュした場合呼び出し側プロセスは直ちに終了する。
    * `async`呼び出しの場合は、`await`時に呼び出し側が終了する
2. スーパーバイザから直接タスクを走らせる
  
  ```ex
  children = [
    worker(Task, [ fn -> do_some() end ])
  ]
  ```

## エージェント
* 状態を持つバックグラウンドプロセス
* エージェントが持つ状態にはどこからでもアクセスできる
* 初期状態は、エージェント開始時に渡した関数によって指定される
* `Agent.get`にエージェントのディスクリプタと関数を渡すことでその状態を問い合わせることが出来る。
* `Agent.update`でエージェントが持つ状態を更新することも出来る。
```ex
{:ok, pid} = Agent.start(fn -> 0 end)  # pid エージェントのPID
Agent.get(pid, &(&1))         # 0
Agent.update(pid, &,(&1+1))   # :ok
Agent.update(pid, &,(&1+1))   # :ok
Agent.get(pid, &(&1))         # 2
```

## エージェントかタスクか、それともGenServerか
#### Q. どんなときにエージェントとタスクを使い、どんなときにGenServerを使うのか？
#### A. 上手く動く、最も簡単なアプローチを使う
* エージェントとタスクは特定のバックグラウンドの機能に適している
* GenServerは一般的(general)


## 知見
* OTPの実装中々重いと感じていたので、Taskの機能を使っていきたい
* 使い所や、使い分けなどは実際にもっと使用していくことで理解していきたい。